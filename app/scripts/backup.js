    var return_string = 'pragma solidity ^0.4.12;/* Need Price Token */contract ' + ConfToken + '{ address internal listenerAddr; address public owner; uint256 public initialIssuance; uint public totalSupply; uint256 public currentEthPrice; /* In USD */ uint256 public currentTokenPrice; /* In USD */ uint256 public ticketPrice; bytes32 public symbol; bytes32 public name; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) public balances; mapping (bytes32 => uint256) public productLimits; mapping (bytes32 => uint256) public productPrices; mapping (address => mapping(bytes32 => uint256)) productOwners; /* Address => (productName => amount) */ function ' + ConfToken + '() { name = "' + name + '"; totalSupply = '+ totalSupply + '; initialIssuance = totalSupply; owner = ' + owner +'; currentEthPrice = ' + currentEthPrice + '; /* TODO: Oracle */ currentTokenPrice = '+ currentTokenPrice + '; /* In cents */ symbol = "'+ symbol +'"; balances[owner] = ' + ownerInitialBalance + '; } /* Math Helpers */ function safeMul(uint a, uint b) constant internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) constant internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) constant internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } /* Methods */ function balanceOf(address _addr) constant returns (uint bal){ return balances[_addr]; } function totalSupply() constant returns (uint){ return totalSupply; } function setTokenPrice(uint128 _amount){ assert(msg.sender == owner); currentTokenPrice = _amount; } function setEthPrice(uint128 _amount){ assert(msg.sender == owner); currentEthPrice = _amount; } function seeEthPrice() constant returns (uint256){ return currentEthPrice; } function __getEthPrice(uint256 price){  /* Oracle Calls this function */  assert(msg.sender == owner);  currentEthPrice = price; } function createProduct(bytes32 name, uint128 price, uint256 limit) returns (bool success){ assert((msg.sender == owner) || (limit > 0)); productPrices[name] = price; productLimits[name] = limit; return true; } function nullifyProduct(bytes32 name){ assert(msg.sender == owner); productLimits[name] = 0; } function modifyProductPrice(bytes32 name, uint256 newPrice){ assert(msg.sender == owner); productPrices[name] = newPrice; productLimits[name] = productLimits[name]; /* ensures Sync */ } function modifyProductLimit(bytes32 name, uint256 newLimit){ assert(msg.sender == owner); productLimits[name] = newLimit; productPrices[name] = productPrices[name]; /* ensures Sync */ } function modifyProductPrice(bytes32 name, uint256 newPrice,uint256 newLimit){ assert(msg.sender == owner); productPrices[name] = newPrice; productLimits[name] = newLimit; } function inventoryProduct(bytes32 name) constant returns (uint productAmnt){ return productLimits[name]; } function checkProduct(bytes32 name) constant returns (uint productAmnt){ return productOwners[msg.sender][name]; } function purchaseProduct(bytes32 name,uint256 amnt){ assert((productLimits[name] > 0) || (safeSub(productLimits[name],amnt) >= 0) || (safeMul(amnt,productPrices[name]) <= balances[msg.sender])  ); uint256 totalPrice = safeMul(productPrices[name],amnt); assert(balances[msg.sender] >= totalPrice); balances[msg.sender] = safeSub(balances[msg.sender], totalPrice); totalSupply += totalPrice; productLimits[name] = safeSub(productLimits[name],amnt); productOwners[msg.sender][name] = safeAdd(productOwners[msg.sender][name],amnt); } function buyToken() payable returns (uint256){ /* Need return Change Function */ assert(msg.value > currentTokenPrice); assert(msg.value > 0); uint256 oneEth = 1000000000000000000; /* calculate price for 1 wei */ uint256 tokenCost = currentTokenPrice * (oneEth/currentEthPrice); assert(msg.value > tokenCost); uint256 totalTokens = (msg.value/tokenCost)/oneEth; assert(totalTokens > 0); if (balances[msg.sender] != 0) { balances[msg.sender] = safeAdd(balances[msg.sender], totalTokens); }else{ balances[msg.sender] = totalTokens; } return totalTokens; } function transfer(address _to, uint256 _value) payable returns (bool success){ assert((_to != 0) && (_value > 0)); assert(balances[msg.sender] >= _value); assert(safeAdd(balances[_to], _value) > balances[_to]); Transfer(msg.sender, _to, _value); balances[msg.sender] = safeSub(balances[msg.sender],_value); balances[_to] = safeAdd(balances[msg.sender], _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success){ assert(allowed[_from][msg.sender] >= _value); assert(_value > 0); assert(balances[_to] + _value > balances[_to]); balances[_from] = safeSub(balances[_from],_value); allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value); balances[_to] = safeAdd(balances[_to], _value); return true; } function approve(address _spender, uint _value) returns (bool success){ allowed[msg.sender][_spender] = _value; return true; } function __redeem() returns (bool success){ assert(msg.sender == owner); assert(msg.sender.send(this.balance)); return true; } function __DEBUG_BAL() returns (uint bal){ return this.balance; } function allowance(address _owner, address _spender) constant returns (uint remaining){ return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval (address indexed _owner, address indexed _spender, uint _value); function() { revert(); }}';

